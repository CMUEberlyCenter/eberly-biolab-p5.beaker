<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: beaker.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: beaker.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Beaker class for use with the acid equilibrium simulation.
 *   Acts as a particle container and manages particle groups.
 * @copyright Carnegie Mellon University 2018
 * @author mouse@cmu.edu (Meg Richards)
 */

/**
 * A beaker/particle container.
 * @class
 * @tutorial beaker-tutorial
 * @param {!object} sketch - Parent p5 sketch.
 * @param {number} [solution_width=100] - Width of area bounding particles.
 * @param {number} [solution_height=100] - Height of area bounding particles.
 * @param {number} [x=0] - X position of beaker.
 * @param {number} [y=0] - Y position of beaker.
 * @param {number} [solution_x=x] - X offset of area bounding particles.
 * @param {number} [solution_y=y]- Y offset of area bounding particles.
 */
function Beaker(sketch,
                solution_width=100,solution_height=100,
                x=0,y=0,
                solution_x=null,solution_y=null) {
    /**
     * The parent p5 sketch containing the particle.
     * @type {object}
     */
    this.p = sketch;

    /**
     * The X position of beaker.
     * @type {number}
     */
    this.x = x;

    /**
     * The Y position of beaker.
     * @type {number}
     */
    this.y = y;

    /**
     * The X offset for the beaker foreground image (e.g. its markings).
     * @type {number}
     * @default this.x+250
     */
    this.fg_x = x+250;

    /**
     * The Y offset for the beaker foreground image (e.g. its markings).
     * @type {number}
     * @default this.x+30
     */
    this.fg_y = y+30;

    /**
     * Hash defining the position of the solution/liquid within the beaker.
     * @type {object}
     * @property {number} x - X offset of area bounding particles.
     * @property {number} y - Y offset of area bounding particles.
     * @property {number} width - Width of area bounding particles.
     * @property {number} height - Height of area bounding particles.
     * @property {number} max_x - X offset + width of area bounding particles.
     * @property {number} max_y - Y offset + height of area bounding particles.
     */
    this.solution = {};
    this.solution.x = solution_x === null ? x : solution_x;
    this.solution.y = solution_y === null ? y : solution_y;
    this.solution.width = solution_width;
    this.solution.height = solution_height;
    this.solution.max_x = this.solution.x + this.solution.width;
    this.solution.max_y = this.solution.y + this.solution.height;
}

/**
 * Relative path of the image for the beaker background.
 * @type {string}
 * @default "assets/beaker.png"
 */
Beaker.prototype.bg_image_path = 'assets/beaker.png';

/**
 * Relative path of the image for the beaker foreground.
 * @type {string}
 * @default "assets/beakerMarkings.png"
 */
Beaker.prototype.fg_image_path = 'assets/beakerMarkings.png';

/**
 * Reference to one particle type within a beaker.
 * @typedef ParticleHash
 * @property {object} sprites - The sprite group for that type of particle.
 */

/**
 * Hash of particles within the beaker referenced by type.
 * @type {?object.&lt;string,ParticleHash>}
 * @example
 * var beaker = new Beaker(p);
 * ...
 * var proton_sprite_group = beaker.particles["Proton"].sprites;
 */
Beaker.prototype.particles = {}; // initialized indirectly via addParticles()

/**
 * Perform any actions required before the beaker can be used.
 * @function preload
 * @static
 * @memberof Beaker
 * @param {object} p - Parent p5 sketch.
 */
Beaker.prototype.preload = function(p) {
    this.background = p.loadImage(this.bg_image_path);
    this.foreground = p.loadImage(this.fg_image_path);
};

/**
 * Draw the beaker &amp; particles within it.
 * Particles are drawn in reverse order to when they were added.
 */
Beaker.prototype.draw = function() {
    var p = this.p;
    // Draw beaker background
    p.image(this.background, this.x, this.y);
    // Draw particles
    // @todo: Protons joined with bases can appear to be sliced through by
    //       higher bases; order should be:
    //       free bases, joined particles, then free protons
    var beaker_particles = this.particles;
    var keys = Object.keys(beaker_particles); // e.g. ["Proton","ConjugateBase"]
    for( var i in keys ) {
        var particles = beaker_particles[keys[i]];
        p5.prototype.drawSprites(particles.sprites);
    }
    // Draw beaker foreground markings
    p.image(this.foreground, this.fg_x, this.fg_y);
};

/**
 * Get a random location within the beaker able to accomodate a particle.
 * @param {number} particle_radius - The radius of the particle to be placed
 * with randomPoint().
 * @return {?GPoint} A random point within the beaker or null if the
 *   particle will not fit.
 */
Beaker.prototype.randomPoint = function(particle_radius) {
    if( particle_radius*2 >= this.solution.width ||
        particle_radius*2 >= this.solution.height )
        return null;
    var min_x = this.solution.x + particle_radius;
    var min_y = this.solution.y + particle_radius;
    // Width &amp; height values are reduced by 1 particle radius on each side
    var max_width = this.solution.width - 2*particle_radius;
    var max_height = this.solution.height - 2*particle_radius;
    var x = min_x + Math.random()*max_width;
    var y = min_y + Math.random()*max_height;
    return new GPoint(x,y);
};

/**
 * Add some number of one type of particle to the beaker.
 * @param {number} quantity - Number of particles to add.
 */
Beaker.prototype.addParticles = function(particle_class,quantity) {
    var p = this.p;
    this.initParticleGroup(particle_class);
    for (var i = 0; i &lt; quantity; i++) {
        var particle_radius = window[particle_class].prototype.collider_radius;
        var location = this.randomPoint(particle_radius);
        if( location ) {
            var particle = new window[particle_class](p,
                                                      location.getX(),
                                                      location.getY());
            this.addParticle(particle_class, particle);
        }
    }
};
Beaker.prototype.initParticleGroup = function(particle_class) {
    var p = this.p;
    if( !this.particles[particle_class] ) {
        this.particles[particle_class] = {};
        this.particles[particle_class].sprites = new p.Group();
    }
};
Beaker.prototype.addParticle = function(particle_key, particle) {
    this.particles[particle_key].sprites.add(particle.sprite);
    //this.particles[particle_key].particles.push(particle);
};

Beaker.prototype.step = function() {
    this.update_particles();
    var bases = this.particles["ConjugateBase"].sprites;
    var joined = 0;
    for( var i = 0; i &lt; bases.length; i++) {
        if( bases[i].particle.proton_sprite != null) {
            joined++;
        }
    }
    numJoined = joined;
    numConjugateBases = conConjugateBases-numJoined;
};

Beaker.prototype.update_particles = function() {
    var beaker_particles = this.particles;
    for( var i in Object.keys(beaker_particles) ) {

        var particle_key = Object.keys(beaker_particles)[i]; // e.g.: "Proton"
        var particles = beaker_particles[particle_key];
        this.boundary_check(particles);


        var reacts_with = window[particle_key].prototype.reacts_with;
        //this.detect_particle_overlaps(particles,reacts_with);

        var sprites = particles.sprites;
        for( var j = 0; j&lt;sprites.length; j++ ){

            var sprite = sprites[j];
            this.detect_particle_overlap(sprite,reacts_with);

            sprite.particle.update();
        }
    }
};

Beaker.prototype.boundary_check = function(particles) {
    // Bounds of beaker solution
    var min_x = this.solution.x;
    var max_x = this.solution.max_x;
    var min_y = this.solution.y;
    var max_y = this.solution.max_y;

    var sprites = particles.sprites;
    // Determine if particle sprite is at a beaker boundary
    for( var i = 0; i&lt;sprites.length; i++ ){
        var sprite = sprites[i];
        if( sprite.overlapPoint(min_x,sprite.position.y) ) {
            sprite.velocity.x = Math.abs(sprite.velocity.x);
        }
        else if( sprite.overlapPoint(max_x,sprite.position.y) ) {
            sprite.velocity.x = -Math.abs(sprite.velocity.x);
        }
        if( sprite.overlapPoint(sprite.position.x,min_y) ) {
            sprite.velocity.y = Math.abs(sprite.velocity.y);
        }
        else if( sprite.overlapPoint(sprite.position.x,max_y) ) {
            sprite.velocity.y = -Math.abs(sprite.velocity.y);
        }
    }
};

Beaker.prototype.detect_particle_overlap = function(sprite,reacts_with) {
    var beaker_particles = this.particles;
    for( var i in Object.keys(reacts_with) ) {
        var target_key = Object.keys(reacts_with)[i]; // e.g.: "Proton"
        var target_group = beaker_particles[target_key].sprites;
        sprite.overlap(target_group,reacts_with[target_key]);
    }
};


//Beaker.prototype.x = 0;
//Beaker.prototype.y = 40;
//Beaker.prototype.fg_x = Beaker.prototype.x + 250;
//Beaker.prototype.fg_y = Beaker.prototype.y + 30;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Beaker.html">Beaker</a></li><li><a href="ConjugateBase.html">ConjugateBase</a></li><li><a href="Particle.html">Particle</a></li><li><a href="Proton.html">Proton</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-beaker-tutorial.html">beaker-tutorial</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Dec 25 2018 18:54:53 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
